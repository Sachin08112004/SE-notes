<html>
    <head>
        <title>Software Engineering Notes</title>
        <link rel="stylesheet" href="SE.css">
        <script src="https://kit.fontawesome.com/234b57edb4.js" crossorigin="anonymous"></script>
    </head>
    <body>
        <header>
            <img class="logo" src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQw66XRnR1kY9Me-jBPX-cIs3Z2yNpeDfZmsqtfEznQKA&s" alt="logo">
            <a class="cta" href="#"><button>Feedback</button></a>
        </header>
        <h1>
            Software Engineering Notes
        </h1>
        <div class="accordian">
            <div class="Topic">
                <h4>Software & Charateristics of a Good Software</h4>
                <i class="icon fa-solid fa-caret-down"></i>
            </div>
            <div class="Description">
                <p>Software refers to a set of instructions, data, or programs used to operate computers and execute specific tasks. It's essentially the non-tangible component of computers, which is used to control and coordinate the hardware components and perform various tasks.</p>
                <p>~Software can be broadly classified into two main categories:</p>
                <ol>
                    <li>
                        <strong>System Software</strong>: This includes operating systems (like Windows, macOS, Linux), device drivers, and utility software. System software is designed to manage and control the hardware components and provide a platform for running application software.
                    </li>
                    <li>
                        <strong>Application Software</strong>: This category consists of programs that help users perform specific tasks. Examples include word processors (like Microsoft Word), web browsers (like Google Chrome), and mobile apps (like Instagram). Application software is designed to help users complete particular processes and activities.
                    </li>
                </ol>
                <p>~Charateristics of a Good Software are:</p>
                <ul>
                    <li><strong>Correctness</strong>: The degree to which software adheres to its specified requirements and performs its functions accurately.</li>
                    <li><strong>Efficiency</strong>: The software's ability to perform its tasks optimally, using minimal resources like memory and processing power.</li>
                    <li><strong>Functionality</strong>: The extent to which software provides a set of functions that meet stated and implied needs.</li>
                    <li><strong>Reliability</strong>: The software's capacity to perform under specified conditions for a specified period of time without failure.</li>
                    <li><strong>Usability</strong>: How easy and intuitive the software is for users, including its user interface and user experience.</li>
                    <li><strong>Maintainability</strong>: The ease with which the software can be modified to correct defects, improve performance, or adapt to a changed environment.</li>
                    <li><strong>Portability</strong>: The ability of the software to be transferred from one environment to another with minimal effort.</li>
                    <li><strong>Scalability</strong>: The software's capacity to handle increased loads or to be enlarged to accommodate that growth.</li>
                    <li><strong>Security</strong>: The degree to which the software is protected against unauthorized access, harm, or manipulation.</li>
                    <li><strong>Cost Effective / Economical</strong>: The software's ability to provide value for money, including development and operational costs.</li>
                    <li><strong>Interoperability</strong>: The capability of the software to interact and exchange data with other systems or components.</li>
                    <li><strong>Robustness</strong>: The software's ability to handle errors during execution and to withstand erroneous inputs.</li>
                </ul>
                
            </div>
        </div>

        <div class="accordian">
            <div class="Topic">
                <h4>Software development Life Cycle (SDLC)</h4>
                <i class="icon fa-solid fa-caret-down"></i>
            </div>
            <div class="Description">
                <p> The Software Development Life Cycle (SDLC) is a structured process used for developing software applications in a systematic and efficient manner. It encompasses several distinct phases, each of which contributes to the successful development, deployment, and maintenance of the software. The goal of SDLC is to produce high-quality software that meets or exceeds customer expectations, completes within time and cost estimates, and is efficient and maintainable.</p>
                <p>~The SDLC typically include the following phases:</p>
                <ul>
                    <li><strong>Requirement Phase</strong>: Gathering and documenting what the software needs to do, defining clear and detailed requirements.</li>
                    <li><strong>Feasibility Phase</strong>: Assessing the practicality and financial viability of the project, ensuring it is technically and legally feasible.</li>
                    <li><strong>Design Phase</strong>: Creating the architecture and design of the system, specifying hardware and system requirements, and defining overall system architecture.</li>
                    <li><strong>Implementation Phase</strong>: Actual coding and development of the software, transforming design documentation into the actual software.</li>
                    <li><strong>Testing Phase</strong>: Systematic discovery and debugging of defects, ensuring the software meets all specifications and requirements.</li>
                    <li><strong>Deployment Phase</strong>: Releasing the finished product to the customer/user environment, often includes installation and basic user training.</li>
                    <li><strong>Maintenance Phase</strong>: Ongoing maintenance and updating of the software, fixing issues, and making improvements based on customer feedback.</li>
                </ul>
                
            </div>
        </div>

        <div class="accordian">
            <div class="Topic">
                <h4>Software Evolution</h4>
                <i class="icon fa-solid fa-caret-down"></i>
            </div>
            <div class="Description">
                <p>Software evolution refers to the process of developing software initially and then continually updating and improving it over time. This concept is rooted in the understanding that software is not static but must adapt, evolve, and be refined throughout its lifecycle to meet changing requirements, technologies, and user needs.</p>
                <p>~Key aspects of software evolution are:</p>
                <ul>
                    <li><strong>Maintenance and Updates</strong>: Regular bug fixes and performance improvements.</li>
                    <li><strong>Adapting to Change</strong>: Modifying software for new technologies and environments.</li>
                    <li><strong>Feature Enhancement</strong>: Adding or improving features to meet user needs.</li>
                    <li><strong>Refactoring</strong>: Restructuring code for better efficiency and maintainability.</li>
                    <li><strong>Standards Compliance</strong>: Ensuring alignment with industry regulations and standards.</li>
                    <li><strong>Technical Debt Management</strong>: Addressing and reducing accumulated technical compromises.</li>
                    <li><strong>Security Updates</strong>: Continuously enhancing security to protect against new threats.</li>
                    <li><strong>Performance Optimization</strong>: Improving efficiency and resource management.</li>
                </ul>
            </div>
        </div>

        <div class="accordian">
            <div class="Topic">
                <h4>Built and Fix Model</h4>
                <i class="icon fa-solid fa-caret-down"></i>
            </div>
            <div class="Description">
                <p> It is the most simple model of software development, the product is constructed with minimal requirements, and generally no specifications nor any attempt at design, and testing is most often neglected. This is a representation of what is happening in many software development projects.</p>
                <p>~This approach offten leads to the folowing characterisctics:</p>
                <ul>
                    <li><strong>Lack of Structure</strong>: Agile approaches often have less formalized structures, which can lead to ambiguities and inconsistent processes.</li>
                    <li><strong>Immediate Coding</strong>: Agile methodologies sometimes emphasize jumping into coding without extensive upfront design, which can lead to oversight in system architecture.</li>
                    <li><strong>Continuous Modification</strong>: Frequent changes can disrupt the development process and make it hard to keep the project on track.</li>
                    <li><strong>Potential for Issues</strong>: Without thorough initial planning, the project can suffer from unforeseen problems and increased technical debt.</li>
                    <li><strong>Not Suitable for Large Projects</strong>: Agile methods can be challenging to apply effectively in very large projects due to coordination complexity.</li>
                </ul>
                
            </div>
        </div>

        <div class="accordian">
            <div class="Topic">
                <h4>Waterfall Model</h4>
                <i class="icon fa-solid fa-caret-down"></i>
            </div>
            <div class="Description">
                <p>It is a linear and sequential approach to software development, typically divided into distinct phases, each must be completed before the next phase begins with little overlap between them.</p>
                <p>~Steps to be followed in Waterfall model are as follows:</p>
                <ul>
                    <li><b>Requirement specification</b> - Gathering and documenting what the software must do.</li>
                    <li><b>System designs</b> - planning the system architecture and design.</li>
                    <li><b>Implementation and System design</b> - Writing the actual software code.</li>
                    <li><b>Integration and system testing</b> - Combining all parts and checking for errors and issues.</li>
                    <li><b>Maintainance</b>- Ongoing support and updates after deployement.</li>
                </ul>
                <p>~Advantages of Waterfall models are:</p>
                <ul>
                    <li><strong>Simplicity</strong>: Its linear, phase-by-phase approach is straightforward and easy to understand.</li>
                    <li><strong>Structured</strong>: Each phase has defined goals and deliverables, aiding in organization.</li>
                    <li><strong>Predictability</strong>: With set phases and milestones, it allows for predictable project timelines and budgets.</li>
                    <li><strong>Documentation</strong>: Emphasizes thorough documentation, which is beneficial for future maintenance and reference.</li>
                    <li><strong>Stability</strong>: Ideal for projects with well-defined, stable requirements, reducing the risk of scope creep.</li>
                </ul>
                <p>~Disadvantages of Waterfall models are:</p>
                <ul>
                    <li><strong>Rigidity</strong>: Difficult to accommodate changes after a phase is completed.</li>
                    <li><strong>Late Testing</strong>: Testing only occurs after development, leading to late discovery of issues.</li>
                    <li><strong>Not Ideal for Complex Projects</strong>: Struggles with evolving or uncertain requirements.</li>
                    <li><strong>Delayed Feedback</strong>: End-user feedback is received only after full development, potentially leading to mismatched user requirements.</li>
                    <li><strong>Higher Risk</strong>: Increased risk and uncertainty, especially for long-term projects.</li>
                </ul>
            </div>
        </div>

        <div class="accordian">
            <div class="Topic">
                <h4>Prototype Model</h4>
                <i class="icon fa-solid fa-caret-down"></i>
            </div>
            <div class="Description">
                <p>The prototype model is a software development approach where a prototype (an early approximation of a final system or product) is built, tested, and then refined as necessary until an acceptable prototype is achieved. This model is particularly useful when the requirements of a project are not well-understood or are subject to change. It helps in understanding and refining the requirements of the project, and in demonstrating and validating the feasibility of the design.</p>
                <p>~Key features of Prototype Models are:</p>
                <ul>
                    <li><strong>Early Visualization</strong>: Stakeholders can see and interact with a preliminary version of the product early in the development process.</li>
                    <li><strong>Iterative Refinement</strong>: The prototype is continuously improved based on feedback until it meets the final requirements.</li>
                    <li><strong>Active User Involvement</strong>: Users are significantly involved in reviewing and providing feedback on the prototype.</li>
                    <li><strong>Clarification of Requirements</strong>: Helps in better understanding and specifying user needs and project requirements.</li>
                    <li><strong>Risk Reduction</strong>: Early prototyping reduces the risks of misunderstandings and incorrect requirements.</li>
                </ul>
            </div>
        </div>

         <!--<div class="accordian">
            <div class="Topic">
                <h4>Built and Fix model</h4>
                <i class="icon fa-solid fa-caret-down"></i>
            </div>
            <div class="Description">
                
                <ul>
                    
                </ul>
            </div>
        </div>
        //-->

         <!--<div class="accordian">
            <div class="Topic">
                <h4>Built and Fix model</h4>
                <i class="icon fa-solid fa-caret-down"></i>
            </div>
            <div class="Description">
                
                <ul>
                    
                </ul>
            </div>
        </div>
        //-->

         <!--<div class="accordian">
            <div class="Topic">
                <h4>Built and Fix model</h4>
                <i class="icon fa-solid fa-caret-down"></i>
            </div>
            <div class="Description">
                
                <ul>
                    
                </ul>
            </div>
        </div>
        //-->

         <!--<div class="accordian">
            <div class="Topic">
                <h4>Built and Fix model</h4>
                <i class="icon fa-solid fa-caret-down"></i>
            </div>
            <div class="Description">
                
                <ul>
                    
                </ul>
            </div>
        </div>
        //-->

         <!--<div class="accordian">
            <div class="Topic">
                <h4>Built and Fix model</h4>
                <i class="icon fa-solid fa-caret-down"></i>
            </div>
            <div class="Description">
                
                <ul>
                    
                </ul>
            </div>
        </div>
        //-->




        <script src="SE.js"></script>
    </body>
</html>
