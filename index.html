<html>
    <head>
        <title>Software Engineering Notes</title>
        <link rel="stylesheet" href="SE.css">
        <script src="https://kit.fontawesome.com/234b57edb4.js" crossorigin="anonymous"></script>
    </head>
    <body>
        <header>
            <img class="logo" src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQw66XRnR1kY9Me-jBPX-cIs3Z2yNpeDfZmsqtfEznQKA&s" alt="logo">
            <a class="cta" href="#"><button>Feedback</button></a>
        </header>
        <h1>
            Software Engineering Notes
        </h1>
        <div class="accordian">
            <div class="Topic">
                <h4>Software & Charateristics of a Good Software</h4>
                <i class="icon fa-solid fa-caret-down"></i>
            </div>
            <div class="Description">
                <p>Software refers to a set of instructions, data, or programs used to operate computers and execute specific tasks. It's essentially the non-tangible component of computers, which is used to control and coordinate the hardware components and perform various tasks.</p>
                <p>~Software can be broadly classified into two main categories:</p>
                <ol>
                    <li>
                        <strong>System Software</strong>: This includes operating systems (like Windows, macOS, Linux), device drivers, and utility software. System software is designed to manage and control the hardware components and provide a platform for running application software.
                    </li>
                    <li>
                        <strong>Application Software</strong>: This category consists of programs that help users perform specific tasks. Examples include word processors (like Microsoft Word), web browsers (like Google Chrome), and mobile apps (like Instagram). Application software is designed to help users complete particular processes and activities.
                    </li>
                </ol>
                <p>~Charateristics of a Good Software are:</p>
                <ul>
                    <li><strong>Correctness</strong>: The degree to which software adheres to its specified requirements and performs its functions accurately.</li>
                    <li><strong>Efficiency</strong>: The software's ability to perform its tasks optimally, using minimal resources like memory and processing power.</li>
                    <li><strong>Functionality</strong>: The extent to which software provides a set of functions that meet stated and implied needs.</li>
                    <li><strong>Reliability</strong>: The software's capacity to perform under specified conditions for a specified period of time without failure.</li>
                    <li><strong>Usability</strong>: How easy and intuitive the software is for users, including its user interface and user experience.</li>
                    <li><strong>Maintainability</strong>: The ease with which the software can be modified to correct defects, improve performance, or adapt to a changed environment.</li>
                    <li><strong>Portability</strong>: The ability of the software to be transferred from one environment to another with minimal effort.</li>
                    <li><strong>Scalability</strong>: The software's capacity to handle increased loads or to be enlarged to accommodate that growth.</li>
                    <li><strong>Security</strong>: The degree to which the software is protected against unauthorized access, harm, or manipulation.</li>
                    <li><strong>Cost Effective / Economical</strong>: The software's ability to provide value for money, including development and operational costs.</li>
                    <li><strong>Interoperability</strong>: The capability of the software to interact and exchange data with other systems or components.</li>
                    <li><strong>Robustness</strong>: The software's ability to handle errors during execution and to withstand erroneous inputs.</li>
                </ul>
                
            </div>
        </div>

        <div class="accordian">
            <div class="Topic">
                <h4>Software development Life Cycle (SDLC)</h4>
                <i class="icon fa-solid fa-caret-down"></i>
            </div>
            <div class="Description">
                <p> The Software Development Life Cycle (SDLC) is a structured process used for developing software applications in a systematic and efficient manner. It encompasses several distinct phases, each of which contributes to the successful development, deployment, and maintenance of the software. The goal of SDLC is to produce high-quality software that meets or exceeds customer expectations, completes within time and cost estimates, and is efficient and maintainable.</p>
                <p>~The SDLC typically include the following phases:</p>
                <ul>
                    <li><strong>Requirement Phase</strong>: Gathering and documenting what the software needs to do, defining clear and detailed requirements.</li>
                    <li><strong>Feasibility Phase</strong>: Assessing the practicality and financial viability of the project, ensuring it is technically and legally feasible.</li>
                    <li><strong>Design Phase</strong>: Creating the architecture and design of the system, specifying hardware and system requirements, and defining overall system architecture.</li>
                    <li><strong>Implementation Phase</strong>: Actual coding and development of the software, transforming design documentation into the actual software.</li>
                    <li><strong>Testing Phase</strong>: Systematic discovery and debugging of defects, ensuring the software meets all specifications and requirements.</li>
                    <li><strong>Deployment Phase</strong>: Releasing the finished product to the customer/user environment, often includes installation and basic user training.</li>
                    <li><strong>Maintenance Phase</strong>: Ongoing maintenance and updating of the software, fixing issues, and making improvements based on customer feedback.</li>
                </ul>
                
            </div>
        </div>

        <div class="accordian">
            <div class="Topic">
                <h4>Software Evolution</h4>
                <i class="icon fa-solid fa-caret-down"></i>
            </div>
            <div class="Description">
                <p>Software evolution refers to the process of developing software initially and then continually updating and improving it over time. This concept is rooted in the understanding that software is not static but must adapt, evolve, and be refined throughout its lifecycle to meet changing requirements, technologies, and user needs.</p>
                <p>~Key aspects of software evolution are:</p>
                <ul>
                    <li><strong>Maintenance and Updates</strong>: Regular bug fixes and performance improvements.</li>
                    <li><strong>Adapting to Change</strong>: Modifying software for new technologies and environments.</li>
                    <li><strong>Feature Enhancement</strong>: Adding or improving features to meet user needs.</li>
                    <li><strong>Refactoring</strong>: Restructuring code for better efficiency and maintainability.</li>
                    <li><strong>Standards Compliance</strong>: Ensuring alignment with industry regulations and standards.</li>
                    <li><strong>Technical Debt Management</strong>: Addressing and reducing accumulated technical compromises.</li>
                    <li><strong>Security Updates</strong>: Continuously enhancing security to protect against new threats.</li>
                    <li><strong>Performance Optimization</strong>: Improving efficiency and resource management.</li>
                </ul>
            </div>
        </div>

        <div class="accordian">
            <div class="Topic">
                <h4>Built and Fix Model</h4>
                <i class="icon fa-solid fa-caret-down"></i>
            </div>
            <div class="Description">
                <p> It is the most simple model of software development, the product is constructed with minimal requirements, and generally no specifications nor any attempt at design, and testing is most often neglected. This is a representation of what is happening in many software development projects.</p>
                <p>~This approach offten leads to the folowing characterisctics:</p>
                <ul>
                    <li><strong>Lack of Structure</strong>: Agile approaches often have less formalized structures, which can lead to ambiguities and inconsistent processes.</li>
                    <li><strong>Immediate Coding</strong>: Agile methodologies sometimes emphasize jumping into coding without extensive upfront design, which can lead to oversight in system architecture.</li>
                    <li><strong>Continuous Modification</strong>: Frequent changes can disrupt the development process and make it hard to keep the project on track.</li>
                    <li><strong>Potential for Issues</strong>: Without thorough initial planning, the project can suffer from unforeseen problems and increased technical debt.</li>
                    <li><strong>Not Suitable for Large Projects</strong>: Agile methods can be challenging to apply effectively in very large projects due to coordination complexity.</li>
                </ul>
                 <p>~Advantages of Build and Fix Model are:</p>
                <ul>
                    <li><strong>Speed:</strong> Allows for rapid development and delivery, especially in small projects or early prototypes, where speed to market is critical.</li>
                    <li><strong>Flexibility:</strong> Developers can make immediate changes without the need to follow a strict plan, accommodating new insights or requirements as they arise.</li>
                    <li><strong>Simplicity:</strong> It's straightforward to implement, without the need for complex processes or extensive documentation, making it suitable for beginners or small teams.</li>
                    <li><strong>Minimal Overhead:</strong> Reduces the need for extensive upfront planning, documentation, and meetings, focusing resources directly on development tasks.</li>
                    <li><strong>Direct Feedback:</strong> Facilitates quick feedback on the working software from users or stakeholders, enabling immediate improvements or fixes.</li>
                  </ul>
                  <p>~Disadvantages of Build and Fix Model are:</p>
                  <ul>
                    <li><strong>Lack of Structure:</strong> Without a defined plan or methodology, projects can become chaotic, especially as they grow in size and complexity.</li>
                    <li><strong>Poor Scalability:</strong> The model doesn't scale well for larger projects or teams, leading to inefficiency and potential confusion.</li>
                    <li><strong>Code Quality Issues:</strong> Rapid development without thorough planning or review processes can result in poor code quality, making future changes or maintenance more challenging.</li>
                    <li><strong>Increased Risk of Technical Debt:</strong> Quick fixes and constant changes can accumulate technical debt, where the cost of rework becomes significantly higher over time.</li>
                    <li><strong>Difficulty in Tracking Progress:</strong> Without clear milestones or documentation, it can be challenging to measure progress or understand the scope of completed work, complicating project management and stakeholder communication.</li>
                  </ul>
            </div>
        </div>

        <div class="accordian">
            <div class="Topic">
                <h4>Waterfall Model</h4>
                <i class="icon fa-solid fa-caret-down"></i>
            </div>
            <div class="Description">
                <p>It is a linear and sequential approach to software development, typically divided into distinct phases, each must be completed before the next phase begins with little overlap between them.</p>
                <p>~Steps to be followed in Waterfall model are as follows:</p>
                <ul>
                    <li><b>Requirement specification</b> - Gathering and documenting what the software must do.</li>
                    <li><b>System designs</b> - planning the system architecture and design.</li>
                    <li><b>Implementation and System design</b> - Writing the actual software code.</li>
                    <li><b>Integration and system testing</b> - Combining all parts and checking for errors and issues.</li>
                    <li><b>Maintainance</b>- Ongoing support and updates after deployement.</li>
                </ul>
                <p>~Advantages of Waterfall models are:</p>
                <ul>
                    <li><strong>Simplicity</strong>: Its linear, phase-by-phase approach is straightforward and easy to understand.</li>
                    <li><strong>Structured</strong>: Each phase has defined goals and deliverables, aiding in organization.</li>
                    <li><strong>Predictability</strong>: With set phases and milestones, it allows for predictable project timelines and budgets.</li>
                    <li><strong>Documentation</strong>: Emphasizes thorough documentation, which is beneficial for future maintenance and reference.</li>
                    <li><strong>Stability</strong>: Ideal for projects with well-defined, stable requirements, reducing the risk of scope creep.</li>
                </ul>
                <p>~Disadvantages of Waterfall models are:</p>
                <ul>
                    <li><strong>Rigidity</strong>: Difficult to accommodate changes after a phase is completed.</li>
                    <li><strong>Late Testing</strong>: Testing only occurs after development, leading to late discovery of issues.</li>
                    <li><strong>Not Ideal for Complex Projects</strong>: Struggles with evolving or uncertain requirements.</li>
                    <li><strong>Delayed Feedback</strong>: End-user feedback is received only after full development, potentially leading to mismatched user requirements.</li>
                    <li><strong>Higher Risk</strong>: Increased risk and uncertainty, especially for long-term projects.</li>
                </ul>
            </div>
        </div>

        <div class="accordian">
            <div class="Topic">
                <h4>Prototype Model</h4>
                <i class="icon fa-solid fa-caret-down"></i>
            </div>
            <div class="Description">
                <p>The prototype model is a software development approach where a prototype (an early approximation of a final system or product) is built, tested, and then refined as necessary until an acceptable prototype is achieved. This model is particularly useful when the requirements of a project are not well-understood or are subject to change. It helps in understanding and refining the requirements of the project, and in demonstrating and validating the feasibility of the design.</p>
                <p>~Key features of Prototype Models are:</p>
                <ul>
                    <li><strong>Early Visualization</strong>: Stakeholders can see and interact with a preliminary version of the product early in the development process.</li>
                    <li><strong>Iterative Refinement</strong>: The prototype is continuously improved based on feedback until it meets the final requirements.</li>
                    <li><strong>Active User Involvement</strong>: Users are significantly involved in reviewing and providing feedback on the prototype.</li>
                    <li><strong>Clarification of Requirements</strong>: Helps in better understanding and specifying user needs and project requirements.</li>
                    <li><strong>Risk Reduction</strong>: Early prototyping reduces the risks of misunderstandings and incorrect requirements.</li>
                </ul>
                <p>~Advantages of prototype models:</p>
                <ul>
                    <li><strong>Early Problem Detection:</strong> Prototypes help identify issues early in the development process, leading to easier and less costly fixes.</li>
                    <li><strong>User Feedback:</strong> Prototypes enable real user interaction, providing valuable feedback to better meet user needs and preferences.</li>
                    <li><strong>Clarified Requirements:</strong> They reveal additional or misunderstood requirements, ensuring the final product aligns closely with user expectations.</li>
                    <li><strong>Reduced Risk:</strong> Prototyping tests feasibility and functionality early on, reducing the risk of project failure.</li>
                    <li><strong>Enhanced Communication:</strong> They serve as tangible references for discussions, improving communication among team members and stakeholders.</li>
                </ul>
                <p>~Disadvantages of prototype models:</p>
                <ul>
                    <li><strong>Resource Intensive:</strong> Creating prototypes can be time-consuming and require additional resources, which can increase the overall cost and duration of a project.</li>
                    <li><strong>Scope Creep:</strong> Frequent changes and additions during the prototyping process can lead to scope creep, where the project expands beyond its original parameters.</li>
                    <li><strong>Overemphasis on Initial Design:</strong> Early focus on design can sometimes overshadow other important aspects like scalability, maintainability, and performance.</li>
                    <li><strong>Misleading Prototypes:</strong> There is a risk that prototypes, especially if not well developed, can give a false sense of completeness or functionality of the final product.</li>
                    <li><strong>User Confusion:</strong> Stakeholders and users might mistake a prototype for the final product, leading to misunderstandings about the capabilities and features of the end product.</li>
                </ul>
                <p>~Applications of prototype models:</p>
                <ul>
                    <li><strong>Early Feedback:</strong> Prototypes enable early user feedback, leading to improvements that better align with user needs and expectations.</li>
                    <li><strong>Clarification of Requirements:</strong> Prototyping helps clarify and refine project requirements, reducing misunderstandings and misalignments.</li>
                    <li><strong>Reduced Risk:</strong> Early detection of design, technical, and feasibility issues through prototyping reduces the risk of project failures.</li>
                    <li><strong>Stakeholder Engagement:</strong> Prototypes provide a tangible representation of the product, increasing stakeholder involvement and buy-in.</li>
                    <li><strong>Iterative Development:</strong> Prototyping supports an iterative approach, allowing for continual refinement and improvement of the product based on feedback.</li>
            </div>
        </div>

        <div class="accordian">
            <div class="Topic">
                <h4>Iterative Waterfall Model</h4>
                <i class="icon fa-solid fa-caret-down"></i>
            </div>
            <div class="Description">
                <p>The Iterative Waterfall Model is a modified version of the classic Waterfall Model used in software development. It allows for revisiting previous phases for refinement, offering more flexibility than the original model's strict linear sequence. This approach helps in better addressing changes and identifying issues early, while still maintaining a structured workflow.</p>
                <p>~Adavantages of Iterative Waterfall Model are:</p>
                <ul>
                    <li><strong>Improved Flexibility:</strong> Allows for modifications to the project at various stages, accommodating changes in requirements or design more easily than the traditional Waterfall model.</li>
                    <li><strong>Early Detection of Issues:</strong> Iterations enable early discovery and resolution of problems, reducing the risk of significant issues in later stages.</li>
                    <li><strong>Enhanced Risk Management:</strong> By revisiting and refining stages, the model helps in identifying and mitigating risks earlier in the development process.</li>
                    <li><strong>Better Client Feedback Incorporation:</strong> It facilitates incorporating feedback from clients or stakeholders at multiple points, leading to a product more closely aligned with user expectations.</li>
                    <li><strong>Structured Yet Adaptable:</strong> Maintains the clear structure and phases of the Waterfall model, making it easy to understand and follow, while adding the adaptability to refine and improve the project iteratively.</li>
                  </ul>
                  <p>~Disadvantages of Iterative Waterfall Model are:</p>
                  <ul>
                    <li><strong>Increased Complexity:</strong> Adding iterations to the Waterfall model increases project management complexity, requiring more effort in planning and documentation to track changes and iterations.</li>
                    <li><strong>Potential for Scope Creep:</strong> With the flexibility to revisit and revise earlier stages, there's a risk of projects expanding beyond their original scope, leading to delays and increased costs.</li>
                    <li><strong>Resource Intensiveness:</strong> Iterations can lead to additional work, requiring more time and resources than initially planned, which can strain budgets and schedules.</li>
                    <li><strong>Integration Challenges:</strong> Frequent changes in earlier phases could lead to integration challenges later in the development process, requiring additional time for testing and adjustments.</li>
                    <li><strong>Partial Loss of Clarity:</strong> While the model aims to maintain the structured approach of the traditional Waterfall model, the introduction of iterations can sometimes blur the clear demarcations between phases, potentially leading to confusion among team members not accustomed to the flexibility.</li>
                  </ul>
                  <p>~Applications of Iterative Waterfall Model are:</p>
                  <ul>
                    <li><strong>Complex Projects:</strong> Ideal for large, complex projects needing detailed planning and phase-wise execution, with some room for refinement.</li>
                    <li><strong>Hardware Development:</strong> Useful in designing and producing hardware where initial designs benefit from subsequent iterations.</li>
                    <li><strong>Regulated Industries:</strong> Fits projects in sectors like healthcare or finance, where compliance is key but adjustments are needed for optimization.</li>
                    <li><strong>Software with Clear Requirements:</strong> Good for software projects with well-understood requirements that might still need fine-tuning.</li>
                    <li><strong>Educational Content:</strong> Suitable for developing educational materials that require structured development with the ability to incorporate feedback.</li>
                </ul>       
            </div>
        </div>

        <div class="accordian">
            <div class="Topic">
                <h4>V-Model</h4>
                <i class="icon fa-solid fa-caret-down"></i>
            </div>
            <div class="Description">
                <p>The V-Model in software engineering is a development methodology that outlines a process of executing software projects where each phase of the development lifecycle corresponds directly to a phase of testing. This model emphasizes verification and validation processes, making sure that each stage of development is thoroughly tested and validated before moving on to the next stage. The structure of the V-Model is designed to resemble the letter "V," where the left descending side represents the sequential steps of design and development phases, and the right ascending side corresponds to the phases of testing and validation, illustrating the concept that for each development activity, there is a corresponding testing activity. This model highlights the importance of incorporating testing early in the development process, ensuring that defects are identified and corrected as early as possible, which can lead to a more efficient and effective software development process.</p>
                <p>~Advantages of V-Model are:</p>
                <ul>
                    <li><strong>Rigidity:</strong> The model is very rigid; changes are hard to implement once the process has started.</li>
                    <li><strong>Late Testing:</strong> Testing starts only after the development phase is completed, which can delay the discovery of fundamental design flaws.</li>
                    <li><strong>Poor Flexibility:</strong> Not suitable for projects where requirements might evolve.</li>
                    <li><strong>No Iterative Development:</strong> Does not support iterative development; each phase must be completed before the next begins.</li>
                    <li><strong>High Risk and Uncertainty:</strong> Not ideal for complex or object-oriented projects where requirements can change.</li>
                </ul>
                <p>~Disadvantages of V-Model are:</p>
                <ul>
                    <li><strong>Rigidity:</strong> The model is very rigid; changes are hard to implement once the process has started.</li>
                    <li><strong>Late Testing:</strong> Testing starts only after the development phase is completed, which can delay the discovery of fundamental design flaws.</li>
                    <li><strong>Poor Flexibility:</strong> Not suitable for projects where requirements might evolve.</li>
                    <li><strong>No Iterative Development:</strong> Does not support iterative development; each phase must be completed before the next begins.</li>
                    <li><strong>High Risk and Uncertainty:</strong> Not ideal for complex or object-oriented projects where requirements can change.</li>
                </ul>
            </div>
        </div>

         <div class="accordian">
            <div class="Topic">
                <h4>Spiral Model</h4>
                <i class="icon fa-solid fa-caret-down"></i>
            </div>
            <div class="Description">
                <p>The Spiral Model is a risk-driven software development process model that combines elements of both iterative and waterfall models, with a particular focus on risk assessment. It was introduced by Barry Boehm in his 1988 article "A Spiral Model of Software Development and Enhancement". This model emphasizes the necessity of early identification and mitigation of risks, making it especially suitable for large, complex, and high-risk projects.

                    In the Spiral Model, the development process is represented as a spiral rather than a linear sequence. Each loop of the spiral represents a phase of the software development process, starting from the innermost loop, expanding outwards with each iteration.</p>
                <p>~Description of the diffrent phases in the Spiral Model are:</p>
                <ol>
                    <li><strong>Planning</strong>: Defining project objectives, alternatives, and constraints.</li>
                    <li><strong>Risk Analysis</strong>: Identifying and mitigating potential project risks.</li>
                    <li><strong>Implementation</strong>: Developing the software through coding and testing.</li>
                    <li><strong>Construction and Release</strong>: Finalizing development, testing thoroughly, and deploying the software to users.</li>
                    <li><strong>Customer Evaluation</strong>: Gathering feedback from users to inform future development.</li>
                    <li><strong>Customer Communication</strong>: Continuously engaging with the customer to ensure the project meets their needs.</li>
                </ol>
                
                <p>~Advantages of Spiral Model are:</p>
                <ul>
                    <li><strong>Effective Risk Management:</strong> Prioritizes early identification and mitigation of risks, reducing potential project pitfalls.</li>
                    <li><strong>Adaptable to Changes:</strong> Flexible in accommodating evolving requirements throughout the development process.</li>
                    <li><strong>Stakeholder Engagement:</strong> Facilitates continuous feedback and involvement from customers or stakeholders, enhancing product relevance.</li>
                    <li><strong>Prototype Development:</strong> Enables early creation of prototypes for testing and refinement, improving the final product's quality.</li>
                    <li><strong>Suitable for Complex Projects:</strong> Ideal for managing large, complex projects by systematically addressing risks and complexities.</li>
                </ul>
                <p>~Disadvantages of Spiral Model are:</p>
                <ul>
                    <li><strong>Complexity:</strong> The model's iterative nature can make it more complex to manage compared to linear approaches.</li>
                    <li><strong>Costly:</strong> Due to extensive documentation and frequent risk assessments, it can be more expensive to implement.</li>
                    <li><strong>Requires Expertise:</strong> Effective risk evaluation and management demand a high level of expertise, making it less suitable for novice teams.</li>
                    <li><strong>Not Ideal for Small Projects:</strong> The process can be too elaborate and resource-intensive for smaller projects.</li>
                    <li><strong>Time-Consuming:</strong> The need for regular reviews and risk management can extend the project timeline.</li>
                </ul>
            </div>
        </div>

        <div class="accordian">
            <div class="Topic">
                <h4>Incremental Model</h4>
                <i class="icon fa-solid fa-caret-down"></i>
            </div>
            <div class="Description">
                <p>The Incremental Model is a method of software development where the product is designed, implemented, and tested incrementally (a little more is added each time) until the product is finished. It involves both development and maintenance. This model divides the product into smaller pieces, which are then developed and delivered in sequences known as increments. Each increment builds on the previous one by adding a functional layer until the full product is complete.</p>
                <p>~Advantages of Incremental Model are:</p>
                <ul>
                    <li><strong>Early Product Delivery:</strong> Allows early release of some functionalities, providing immediate value to users.</li>
                    <li><strong>Feedback Incorporation:</strong> Facilitates the inclusion of user feedback after each increment, improving the final product.</li>
                    <li><strong>Risk Management:</strong> Enables identification and mitigation of risks early in the development process.</li>
                    <li><strong>Flexibility:</strong> Offers the ability to adapt to changing requirements throughout the development lifecycle.</li>
                    <li><strong>Efficient Testing:</strong> Simplifies the testing process by focusing on smaller, more manageable segments.</li>
                </ul>
                <p>~Disadvantages of Incremental Model are:</p>
                <ul>
                    <li><strong>Complex Dependency Management:</strong> Managing dependencies between increments can become complex.</li>
                    <li><strong>Increased Overhead:</strong> The need for repeated planning, testing, and integration increases overhead costs.</li>
                    <li><strong>Architectural Rigidity:</strong> Early decisions on the architecture can limit future flexibility and changes.</li>
                    <li><strong>Partial Functionality:</strong> Early increments may offer limited functionality, affecting user experience.</li>
                    <li><strong>Resource Allocation Challenges:</strong> Efficiently allocating resources across increments can be challenging.</li>
                </ul>                
            </div>
        </div>

        <div class="accordian">
            <div class="Topic">
                <h4>Comparative description of all the Software Development Lifecycle Models</h4>
                <i class="icon fa-solid fa-caret-down"></i>
            </div>
            <div class="Description">
                <p>~Build and Fix Model</p>
                <ul>
                    <li><strong>Cost</strong>: Generally low initially but can significantly increase due to lack of structure.</li>
                    <li><strong>Risk Management/Analysis</strong>: Minimal formal risk management.</li>
                    <li><strong>Flexibility</strong>: Very high, as changes can be made anytime.</li>
                    <li><strong>Time Taken</strong>: Can be quick for small projects but unpredictable for larger ones.</li>
                    <li><strong>Suitable for Which Type of Projects</strong>: Very small or personal projects.</li>
                    <li><strong>Difference in Phases/Steps</strong>: Lacks defined phases or steps.</li>
                    <li><strong>Complexity</strong>: Low initially but can become unmanageably high.</li>
                    <li><strong>Documentation</strong>: Minimal to none.</li>
                    <li><strong>Resources Management/Uses</strong>: Inefficient due to potential for redoing work.</li>
                    <li><strong>Examples</strong>: Personal or academic projects where requirements are unclear.</li>
                </ul>
                
                <p>~Classic Waterfall Model</p>
                <ul>
                    <li><strong>Cost</strong>: More predictable, but late changes are costly.</li>
                    <li><strong>Risk Management/Analysis</strong>: Limited due to sequential nature.</li>
                    <li><strong>Flexibility</strong>: Low; changes are difficult once the process has started.</li>
                    <li><strong>Time Taken</strong>: Predictable for well-defined projects.</li>
                    <li><strong>Suitable for Which Type of Projects</strong>: Well-understood, straightforward projects with clear requirements.</li>
                    <li><strong>Difference in Phases/Steps</strong>: Strict sequential phases: Requirements, Design, Implementation, Verification, Maintenance.</li>
                    <li><strong>Complexity</strong>: Suitable for managing complexity in well-understood domains.</li>
                    <li><strong>Documentation</strong>: High; requires thorough documentation at each phase.</li>
                    <li><strong>Resources Management/Uses</strong>: Structured, but changes can lead to inefficiencies.</li>
                    <li><strong>Examples</strong>: Construction projects, manufacturing processes.</li>
                </ul>
                
                <p>~Prototype Model</p>
                <ul>
                    <li><strong>Cost</strong>: Moderate initially; depends on prototype complexity.</li>
                    <li><strong>Risk Management/Analysis</strong>: Better, as early prototyping identifies issues.</li>
                    <li><strong>Flexibility</strong>: High, especially in early stages.</li>
                    <li><strong>Time Taken</strong>: Can be quick but varies with the prototype iteration cycle.</li>
                    <li><strong>Suitable for Which Type of Projects</strong>: Projects with unclear user requirements.</li>
                    <li><strong>Difference in Phases/Steps</strong>: Emphasizes initial prototyping to refine requirements.</li>
                    <li><strong>Complexity</strong>: Can handle complex projects by simplifying through prototypes.</li>
                    <li><strong>Documentation</strong>: Varies; less emphasis on documentation early on.</li>
                    <li><strong>Resources Management/Uses</strong>: Focuses on early resource allocation for prototype development.</li>
                    <li><strong>Examples</strong>: Software development, new product development.</li>
                </ul>
                
                <p>~Iterative Waterfall Model</p>
                <ul>
                    <li><strong>Cost</strong>: Similar to classic but may increase due to iterations.</li>
                    <li><strong>Risk Management/Analysis</strong>: Improved with iterations allowing for earlier detection of issues.</li>
                    <li><strong>Flexibility</strong>: Moderately high due to iterations within phases.</li>
                    <li><strong>Time Taken</strong>: Longer than classic waterfall due to iterative reviews.</li>
                    <li><strong>Suitable for Which Type of Projects</strong>: Projects where requirements may evolve.</li>
                    <li><strong>Difference in Phases/Steps</strong>: Adds iterations to the classic waterfall's linear phases.</li>
                    <li><strong>Complexity</strong>: Can manage complexity through iteration, improving understanding.</li>
                    <li><strong>Documentation</strong>: Extensive, with additional focus on iteration documentation.</li>
                    <li><strong>Resources Management/Uses</strong>: More dynamic, adjusting with each iteration's needs.</li>
                    <li><strong>Examples</strong>: Software development projects with evolving requirements.</li>
                </ul>
                
                <p>~V Model</p>
                <ul>
                    <li><strong>Cost</strong>: Comparable to waterfall; potentially higher due to extensive testing.</li>
                    <li><strong>Risk Management/Analysis</strong>: Strong emphasis on testing reduces risks.</li>
                    <li><strong>Flexibility</strong>: Low; similar to waterfall.</li>
                    <li><strong>Time Taken</strong>: Comparable to waterfall but with added time for rigorous testing.</li>
                    <li><strong>Suitable for Which Type of Projects</strong>: Projects with well-defined requirements.</li>
                    <li><strong>Difference in Phases/Steps</strong>: Parallel testing phases corresponding to development phases.</li>
                    <li><strong>Complexity</strong>: Manages complexity through detailed planning and testing.</li>
                    <li><strong>Documentation</strong>: High, with detailed requirements and test documentation.</li>
                    <li><strong>Resources Management/Uses</strong>: Structured, with significant resources allocated to testing.</li>
                    <li><strong>Examples</strong>: Safety-critical projects, like aerospace or medical software.</li>
                </ul>
                
                <p>~Spiral Model</p>
                <ul>
                    <li><strong>Cost</strong>: Potentially high due to iterative risk management.</li>
                    <li><strong>Risk Management/Analysis</strong>: Core feature; assesses risks at each iteration.</li>
                    <li><strong>Flexibility</strong>: Very high; adapts to project needs through each spiral.</li>
                    <li><strong>Time Taken</strong>: Can be lengthy due to iterative planning and risk assessment.</li>
                    <li><strong>Suitable for Which Type of Projects</strong>: High-risk projects, large complex systems.</li>
                    <li><strong>Difference in Phases/Steps</strong>: Combines elements of both prototyping and waterfall in an iterative manner.</li>
                    <li><strong>Complexity</strong>: Well-suited to manage high complexity and risk.</li>
                    <li><strong>Documentation</strong>: Varies; focused on risk and development documentation.</li>
                    <li><strong>Resources Management/Uses</strong>: Intensive, especially for risk assessment and iterative development.</li>
                    <li><strong>Examples</strong>: Large, complex, and high-risk software projects.</li>
                </ul>
                
                <p>~Incremental Model</p>
                <ul>
                    <li><strong>Cost</strong>: Managed incrementally, which can aid in budgeting; total cost can accumulate.</li>
                    <li><strong>Risk Management/Analysis</strong>: Risks managed per increment; allows for adjustments.</li>
                    <li><strong>Flexibility</strong>: Medium to high; allows changes before each increment.</li>
                    <li><strong>Time Taken</strong>: Can be efficient as portions of the project are delivered incrementally.</li>
                    <li><strong>Suitable for Which Type of Projects</strong>: Projects that can be delivered in parts.</li>
                    <li><strong>Difference in Phases/Steps</strong>: Development is divided into increments with each going through the full development cycle.</li>
                    <li><strong>Complexity</strong>: Can manage complexity by breaking down the project into smaller, manageable increments.</li>
                    <li><strong>Documentation</strong>: Required for each increment, can be substantial.</li>
                    <li><strong>Resources Management/Uses</strong>: Allows for efficient allocation per increment.</li>
                    <li><strong>Examples</strong>: Software development, product development with clear stages.</li>
                    </ul>
            </div>
        </div>

         <!--<div class="accordian">
            <div class="Topic">
                <h4>Built and Fix model</h4>
                <i class="icon fa-solid fa-caret-down"></i>
            </div>
            <div class="Description">
                
                <ul>
                    
                </ul>
            </div>
        </div>
        //-->

         <!--<div class="accordian">
            <div class="Topic">
                <h4>Built and Fix model</h4>
                <i class="icon fa-solid fa-caret-down"></i>
            </div>
            <div class="Description">
                
                <ul>
                    
                </ul>
            </div>
        </div>
        //-->

         <!--<div class="accordian">
            <div class="Topic">
                <h4>Built and Fix model</h4>
                <i class="icon fa-solid fa-caret-down"></i>
            </div>
            <div class="Description">
                
                <ul>
                    
                </ul>
            </div>
        </div>
        //-->

         <!--<div class="accordian">
            <div class="Topic">
                <h4>Built and Fix model</h4>
                <i class="icon fa-solid fa-caret-down"></i>
            </div>
            <div class="Description">
                
                <ul>
                    
                </ul>
            </div>
        </div>
        //-->

         <!--<div class="accordian">
            <div class="Topic">
                <h4>Built and Fix model</h4>
                <i class="icon fa-solid fa-caret-down"></i>
            </div>
            <div class="Description">
                
                <ul>
                    
                </ul>
            </div>
        </div>
        //-->




        <script src="SE.js"></script>
    </body>
</html>
